// "establish in-sync replica set membership" as a replica
member(G, M)@async :- begin(M), group(M, G);

// Propagate the in-sync replica info to other replicas
member(M, N)@async :- group(G, G), member(G, M), member(G, N), M != G, notin propagate(G, M, N);
propagate(G, M, N)@next :- group(G, G), member(G, M), member(G, N), M != G;

// Maintain in-sync replica information across time
member(M, N)@next :- member(M, N), notin crash(M, N, _);
member(M, N)@next :- member(M, N), crash(M, N, Time), now(M, Now), Now < Time;

// Propagate the in-sync replica info to client
member(C, M)@async :- group(G, G), member(G, M), client(G, C), notin propagate(G, C, M);
propagate(G, C, M)@next :- group(G, G), member(G, M), client(G, C);

// Maintain knowledge of primary across time
update_primary(M, Node)@async :- group(G, G), member(G, M), promote(G, Node);
update_primary(C, Node)@async :- group(G, G), client(G, C), promote(G, Node);
primary(M, L)@next :- primary(M, L), notin update_primary(M, _), notin crash(M, M, _);
primary(M, L)@next :- primary(M, L), notin update_primary(M, _), crash(M, M, Time), now(M, Now), Now < Time;
primary(M, Node)@next :- update_primary(M, Node);

// Clients known to the group "G"
client(G, C)@async :- clients(C), group(C, G), notin client_reg(C, G);
client_reg(C, G)@next :- clients(C), group(C, G);
client(G, C)@next :- client(G, C), notin crash(G, C, _);
client(G, C)@next :- client(G, C), crash(G, C, Time), now(G, Now), Now < Time;

// Primry promotion, with the node with the max nodieid being promoted. This is the reverse order to the order in which staggered replica writes 
// are propagated.
promote(G, Node) :- group(G, G), max_nodeid(G, Nodeid), nodeid(G, Node, Nodeid), primary(G, Primary), Primary !=Node;
promote(G, Node) :- group(G, G), max_nodeid(G, Nodeid), nodeid(G, Node, Nodeid), notin primary(G, Node);
