include "custom_zk.ded";

// leader to replicas
leader_write(Next, Data, Origin)@async :- write(Origin, Data, Prev), member(Origin, Next), Origin!=Next, leader(Origin, Origin), notin exclude(Next), notin ack_int(Origin, Data, Next);
leader_write(N,D,O)@next :- leader_write(N, D, O);
ack_int(Origin, Data, Acker)@async :- leader_write(Acker, Data, Origin), notin leader(Acker, Acker);
ack_int(O,D,A)@next :- ack_int(O,D,A);
chain_ack(O,D,A)@next :- chain_ack(O,D,A);
chain_ack(Origin, Data, Acker)@async :- leader(Acker, Acker), write(Acker, Data, Origin), Origin != Acker, notin missing_ack(Acker, Data, _);
missing_ack(Leader, Data, Other) :- leader_write(Leader, Data, _), member(Leader, Other),  Leader != Other, notin exclude(Other), notin ack_int(Leader, Data, Other);

//Route to leader
exclude(M)@async :- write(M, D, Origin), leader(M, Leader), Leader!=M, Leader!=Origin;
exclude(M)@next :- exclude(M);
write(Leader, D, M)@async :- write(M, D, Origin), leader(M, Leader), Leader!=M;
writeiN,D,O)@next :- write(N, D, O);
chain_ack(Origin, Data, Acker)@async :- write(Acker, Data, Origin), notin clients("Z", Origin), write(Acker2, Data, Acker), chain_ack(Acker, Data, Acker2), notin leader(Acker, Acker);
ack(Origin, Data, Acker)@async :- write(Acker, Data, Origin), zookeeper(Z,Z), clients(Z,Origin),  write(Node, Data, Acker), chain_ack(Acker, Data, Node), notin leader(Acker,Acker);
ack(Origin,Data,Acker)@async :- chain_ack(Origin, Data, Acker), zookeeper(Z,Z), clients(Z, Origin), leader(Acker,Acker);
ack(Origin, Data, Acker)@next :- ack(Origin, Data, Acker);

// client
//write(M, D, O)@async :- write_req(O, D), member(O, M);

// replica init
zookeeper("a", "Z")@1;
zookeeper("b", "Z")@1;
zookeeper("c", "Z")@1;
zookeeper("C", "Z")@1;
zookeeper("Z", "Z")@1;
begin("a")@1;
begin("b")@1;
begin("c")@1;

// client init
client("C")@1;

// bogus stuff
leader("Z", "a")@1;
member("Z", "a")@1;

// write stream. This is a write to a non-primary. Write to primary can be 
// simulated by chaging the destination to "a" instead of "b"
write("b", "Data1", "C")@2;

// assertions
tried(C, D)@next :- tried(C, D);
tried(C, D) :- write_req(C, D);

good(D) :- ack("C", D, _), write(R, D, _), notin crash(R, R, _);
good(D) :- tried(C, D), notin ack(C, D, _);

// a pathological case that occurs due to our "preordination" of a as leader
good(D) :- tried(C, D), leader(C, L), notin member(C, L);
//good(D) :- member(D, _);

pre(X) :- ack(_, X, _);
post(X) :- ack(_, X, _), write(R, X, _), notin crash(R,R,_);
